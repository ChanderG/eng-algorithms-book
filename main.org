#+TITLE: Engineering Algorithms
#+SETUPFILE: theme/theme-readtheorg.setup
#+OPTIONS: H:3
** About
   This book or more specifically guide is focussed on an *enginneering* approach to
   basic algorithms and data structures.

   I leave the /Science/ to the more eshtablished books, focussing on the /Engineering/ 
   aspects instead.

   The way this book would work is by offloading the teaching aspects to other works, giving
   pointers at every stage. We guide the user to try out these algorithms in a practical way.
   The standard techniques in usual CS courses is to list the psuedo codes and leave it at 
   that.

   We would like to bring in testing, modularity, scalability and comparision of the
   performance on real world ish data and inputs.

   We encourage engineering algorithms in 2 different languages: one high level and one 
   low level.
   We will assume Python and C/C++ without loss of generality.

   This way the reader can get an appreciation of the differences in the levels of the
   language.
*** Resources
    One off resources are linked inline.
    Important/recurring resources are listed [[file:resources.org][here]].
-----
** Introduction: Order Notation
*** Order Notation
**** Goals
     + To understand the Order notation.
     + To setup a framework for timing implementations and comparing them.
**** Reading
     Read the corresponding chapter R2(most ideal introduction).

     Go through the wiki page: https://en.wikipedia.org/wiki/Big_O_notation.
     Look at the corresponding sections in R1 ( math heavy ).

     Search terms: asymptotic notation, growth rates etc.
**** Doing
     Learn to time programs. We can look at 2 approaches.
     - *Langauge Agnostic* ::
        The unix command ~time~ can be used to time commands externally.
     - *Language Specific* ::
        Some languages have easy to use in-built timing functions. 
        For example, python has it's ~timeit~ module. Look at: 
        https://docs.python.org/2/library/timeit.html

    Now try some simple tests of timing.
    + Compare time taken between 2 different orders (like O(n^2) and O(n^3))
      You can use nested for loops with some dummy operation inside.
    + Try varying n and see effect.
    + Try varying the operation inside and see the effect.

    Look at E2.1
** Sorting
